# 이건 뭐지

```js
pragma solidity >=0.4.25 <0.6.0 ;

contract Sample {
	function getValueType() public pure returns (uint) {
		uint a;
		a = 1;
		uint b = a;
		b = 2;
		return a;	// 1
	}

	function getReferenceType() public pure returns (uint[2] memory) {
		uint[2] memory a;
		a[0] = 1;
		a[1] = 2;

		uint[2] memory b = a;
		b[0] = 10;
		b[1] = 20;

		return a;	// 10, 20
	}
}
```

![레퍼런스 타입 출력](./imgs/refe.png)

## 정수형(int, uint)

```js
pragma solidity >=0.4.25 <0.6.0;

contract Sample {
    function div() public pure returns (uint) {
        uint a = 3;
        uint b = 2;
        uint c = a / b * 10;
        return c; // 0: uint256: 10
    }

    function divLiteral() public pure returns (uint) {
        uint c = 3 / 2 * 10;
        return c; // 0: uint256: 15
    }

    function divByZero() public pure returns (uint) {
        uint a = 3;
        uint b = 3 / 0; // TypeError: Operator / not compatible with types int_const 3 and int_const 0
        uint c = a / 0; // TypeError: Division by zero.
        return c;
    }

    function shift() public pure returns (uint[2] memory) {
        uint[2] memory a;
        a[0] = 16 << 2; // 16 * 2^2
        a[1] = 16 >> 2; // 16 / 2^2
        return a;
    }
}
```

## 불린형(bool)

true, false를 값으로 가지는 타입  
정수형으로 변환되지 않음

```js
pragma solidity >=0.4.25 <0.6.0;

contract Sample {
	function getTrueAndFalse() public pure returns (bool) {
		bool a = true;
		bool b = false;
		return a && b;		// false
	}

	function getTrueOrFalse() public pure returns (bool) {
		bool a = true;
		bool b = false;
		return a || b;		// true
	}
}
```

## 바이트 배열

bytes1, bytes2, bytes3, …, bytes32 ⇒ 값 타입의 바이트 배열  
bytes => 참조 타입의 동적 크기 바이트 배열  
string => 참조 타입의 동적 크기의 utf-8 인코딩된 문자열
